[TOC]



# MySQL

![1550129557975](https://github.com/flymecode/MX-Notes/blob/master/image/1550129557975.png)

## 数据库设计三范式

### 第一范式

确保每一列的原子性，每列都不能拆分

### 第二范式

在第一范式的基础上，非主字段必须依赖主字段，一个表只负责一件事情

### 第三范式

在第二范式的基础上，消除传递依赖

### 反三范式：

反三范式是基于第三范式所调整的，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低
范式标准，适当保留冗余数据。



## 索引模块

### 为什么要使用索引？

​	使用索引能够避免我们全表查找数据

### 什么样的信息能够成为索引？

主键

### 索引的数据结构？

二叉查找树

- B+Tree 更适合用来做存储索引

- B+Tree树的磁盘读写代价更低

- B+Tree的铲鲟效率更加稳定

- B+Tree更有利于对数据库的扫描

特点

- 非叶子节点的子树指针与关键字个数相同
- 非叶子节点的子树指针P[i]，指向关键字值[K[i],K[i+1]]的子树
- 非叶子节点仅仅用来做索引，数据都是保存在叶子节点中
- 所有叶子节点具有一个链指针指向下一个叶子节点



### 密集索引和稀疏索引的区别？

- 密集索引文件中每一个搜索码值都对应一个索引值

- 稀疏索引文件只为索引码的某些值建立索引项

- MyISAM 是稀疏索引

- InnoDB有且仅有一个密集索引



### InnoDB的索引

- 若一个主键被定义，该主键则作为密集索引
- 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引
- 若都不满足以上条件，innodb内部会生成一个隐藏的主键
- 非主键索引存储相关键位和其对应的主键值，包含两次查找



### 如何定位并优化慢查询Sql

1. show variables like '%query%'
2. show status like '%slow_queries%'

![1550139826980](https://github.com/flymecode/MX-Notes/blob/master/image/1550139826980.png)

![1550139854091](https://github.com/flymecode/MX-Notes/blob/master/image/1550139854091.png)

1. 打开慢查询
2. set global slow_query_log = on
3. set global long_query_time = 1;
4. 根据慢日志定位慢查询 sql
5. 添加explain分析sql

### 让sql尽量走索引

![1550139799373](https://github.com/flymecode/MX-Notes/blob/master/image/1550139799373.png)



### 联合索引（由多列组成的索引）的最左匹配原则的成因？



![1550143900092](https://github.com/flymecode/MX-Notes/blob/master/image/1550143900092.png)

mysql创建复合索引首先对sql最左边的索引字段进行排序，在排序的基础上再对第二个索引的字段进行排序。



### 索引是建立的越多越好吗？

数据量小的表不需要建立索引，建立会增加额外的索引开销

数据变更要维护索引，因此更多的索引意味更多的维护成本

更多的索引意味着也需要更多的空间



### 隔离级别

​	一个事务与其它事务的隔离程度称为隔离级别

​	当有两个事务并发执行的时候，有可能发生脏读，不可重复读，幻读

| 类型       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读取到另一个事务未提交的数据                         |
| 不可重复读 | 一个事务第二次读取的数值跟第二次读取的不一致                 |
| 幻读       | 一个事务读取到表中的一部分数据，另一个事务向数据库中插入或删除一些数据，此时事务再读取的话就会出现数据不一致。 |



| 类型     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 读未提交 | （允许tx1读取tx2未提交的事务）                               |
| 读已提交 | 要求tx1只能读取tx2已经提交的修改                             |
| 可重复读 | 确保tx1可以多次从一个字段中取到相同的值，即tx1执行期间禁止其它的事务可以对这个字段进行更新。 |
| 串行化   | 确保tx1可以多次从一个表找那个读取到相同的行，在tx1执行期间，禁止其它的事务对这个表进行添加，删除，更新操作。 |



### 事务日志

存储引擎在修改数据表的时候，只需要修改内存的拷贝，再把该修改的记录到持久化的硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘上。事务日志是采用追加的方式，因此写日志的操作是磁盘上一小块区域的顺序 I/O ,而不是随机 I/O ,需要在磁盘的多个地方移动磁头。事务日志持久之后，内存中被修改的数据慢慢的刷回磁盘。修改数据需要写两次磁盘。

### 隐式和显式锁定

InnoDB 采用两段锁协议，在事务执行的过程中，随时都可以加锁，锁只有在 commit 和 rollback 的时候才会释放，并且所有的锁是同一时刻释放的。

InnoDB 也支持通过特定的语句进行显示的锁定

`select ... lock in share mode`

`select ... for update`

### 多版本并发控制

MySQL 大多数的事务型存储实现都不是简单的行级锁，基于对并发的考虑。一般都实现了多版本的并发控制（MVCC）。可以认为 MVCC 是行级锁的一个变种。

MVCC 的实现是通过保存数据在某个时间点的快照来实现的。

InnoDB 的 MVCC ，是通过在每行记录的后面保存两个隐藏的列来实现的，一个保存创建的时间，一个保存删除的时间。实际上保存的不是实际的时间而是系统的版本号，每次开启一个事务，系统的版本号就会递增。事务开始时刻的系统版本号作为事务的版本号。并只能在 read committed 和 repeatable read 两个隔离级别下进行。

优势：

- 使大多数读操作都可以不用加锁
- MVCC 使用间隙锁来防止幻读的出现。间隙锁不仅锁定特定的行，还会对索引中的间隙进行锁定。0·

劣势：

- 需要额外的空间保存版本号

- 需要做一些额外的工作

  

### 索引

索引（Index）是帮助MySQL高效获取数据的数据结构。

> MyISAM索引实现

MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：



![1556173860235](..\image\%5CGit%5CTTMS%5CMX-Notes%5Cimage%5C1556173860235.png)

​										图 8 Primary Key

这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：



![1556173774276](..\image\%5CGit%5CTTMS%5CMX-Notes%5Cimage%5C1556173774276.png)

​									图 9 Secondary Key

同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。

> InnoDB 索引实现

InnoDB的数据文件本身就是索引文件。
 MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。



![1556173541155](..\image\%5CGit%5CTTMS%5CMX-Notes%5Cimage%5C1556173541155.png)



​										图 10 Primary Key

图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：



![1556173584578](..\image\%5CGit%5CTTMS%5CMX-Notes%5Cimage%5C1556173584578.png)

​										图 11 Secondary Key

聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

> 最左前缀原理与相关优化

titles表的主索引为<emp_no, title, from_date>，还有一个辅助索引<emp_no>。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：

```txt
SHOW INDEX FROM employees.titles;
+--------+------------+----------+--------------+-------------+-----------+-------------
| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |
+--------+------------+----------+--------------+-------------+-----------+-------------
| titles |  0 | PRIMARY  |  1 | emp_no    | A   |     NULL |     | BTREE      |
| titles |  0 | PRIMARY  |  2 | title     | A   |     NULL |     | BTREE      |
| titles |  0 | PRIMARY  |  3 | from_date | A   |   443308 |     | BTREE      |
| titles |  1 | emp_no   |  1 | emp_no    | A   |   443308 |     | BTREE      |
+--------+------------+----------+--------------+-------------+-----------+-------------
ALTER TABLE employees.titles DROP INDEX emp_no;
```

理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引

```
EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title='Senior Engineer' AND from_date='1986-06-26';
+----+-------------+--------+-------+---------------+---------+---------+----------------
| id | select_type | table  | type  | possible_keys | key | key_len | ref | rows | Extra 
+----+-------------+--------+-------+---------------+---------+---------+----------------
|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59 | const,const,const| 1
+----+-------------+--------+-------+---------------+---------+---------+----------------


EXPLAIN SELECT * FROM employees.titles WHERE from_date='1986-06-26' AND emp_no='10001' AND title='Senior Engineer';
+----+-------------+--------+-------+---------------+---------+---------+----------------
| id | select_type | table  | type  | possible_keys | key| key_len | ref | rows | Extra |
+----+-------------+--------+-------+---------------+---------+---------+----------------
|  1 | SIMPLE      | titles | const | PRIMARY     | PRIMARY | 59|const,const,const |  1
+----+-------------+--------+-------+---------------+---------+---------+----------------
```

### 事务

​	事务就是一组原子性操作，或者说是一个独立的操作单元。事务内的语句要么全部执行完成，要么全部执行失败。

### ACID特性

- 原子性（atomicity）

一个事务必须被视为一个不可分割的最小的工作单元，整个事物中的所有操作要么全部提交成功，要么全部执行失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

- 一致性（consistency）

数据库总是从一个一致性状态转换到另一个一致性状态。

- 隔离性（isolation）

通常来说，一个事务所做的修改在提交之前，对其他事务时不可见。

- 持久性（durability）

一旦事务提交，则其所做的修改就会永久保存到数据库中

### 隔离级别

隔离级别规定一个事务中所做的修改对其他事务的可见性。

#### READ UNCOMMITTED(未提交读)

READ COMMITTED(提交读)

REPEATABLE READ(可重复读)

SERIALIZABLE(可串行化)