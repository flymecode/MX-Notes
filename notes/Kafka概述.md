Kafka 之所以越来越收青睐主要是它扮演的三大角色分不开

- **消息系统** **:** Kafka 和传统的消息系统都具备系统的解藕、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。Kafka 还提供了消息顺序性保障以及回溯消费的功能。
- **存储系统 :** Kafka 可以将消息持久化到磁盘，所以我们可以将 Kafka 作为长期的数据存储系统来使用。
- **流式处理平台****：**Kafka 不仅为每个流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理类库，比如窗口，连接，变换和聚合等各类操作。

一个典型的Kafka 体系架构包括若干个 Producer、若干 Broker、若干 Consumer，以及一个 Zookeeper 是 Kafka 用来负责集群原数据的管理、控制器的选举等操作。Producer 将消息发送到 Broker ，Broker 负责将收到的消息存储到磁盘中，而 Consumer 负责从 Broker 订阅并消费消息。

![image-20190723205248106](/Users/maxu/MX-Notes/image/image-20190723205248106.png)

整个 Kafka 引入三个术语

1. **Producer：**生产者，负责创建消息，然后投递大 Kafka。
2. **Consumer：**消费者，接受消息，进行相应的逻辑处理。
3. **Broker：**服务代理节点。我们可以将 Broker 简单的看成一个独立的 Kafka 服务节点或者 Kafka 服务实例。

Kafka 中还有两个比较重要的概念：主题和分区

Kafka 中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题，消费者负责订阅主题并进行消费。

主题是一个逻辑上的概念它可以细分为多个分区，一个分区只属于单个主题，很多时候也会把分区称为主题分区。同一主题下的不同分区包含的消息是不同的，分区在存储层面可以看作是一个可以追加的日志文件（log）

消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。offset 是在消息分区中唯一标识， Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不能跨越分区。就是说 Kafka 保证的是分区

的有序性而不是主题的有序。

![image-20190723205313219](/Users/maxu/MX-Notes/image/image-20190723205313219.png)

如图，主题中有三个分区，消息被顺序追加到每个分区日志文件的尾部。Kafka 中的分区可以分布在不同的服务器上 Broker 上，也就是说一个主题可以跨越几个 broker，以此来提供更加强大的功能。

每条消息被发送到 broker 之前，会根据分区规则来选择存储到哪个分区。如果分区规则设定的合理，所有的消息都可以分配到不同的分区中。如果一个主题只对应一个文件，那么这个文件所在的及其 I/O 将会成为这个

主题的性能瓶颈。分区解决了这个问题，在创建主题的时候我们可以指定分区的数量来实现水平的扩展。

kafka 为了分区引入来多副本（Replica）的机制，通过增加副本的数量可以提升容灾能力。同一分区的不同副本中保存的是相同的消息（在同一时刻副本中保存的消息并不是完全一样的），副本之间是一主多从的关系，其中 leader 副本负责处理读写请求， follower 副本负责与 leader 副本的消息同步。副本处于不同 broker 中，副本出现故障的时候，从 follower 副本中重新选举 leader 副本对外提供服务。Kafka 通过多副本机制实现故障的自动转移，当集群中某个broker 失效的时候仍然可以保证服务的可用。

Kafka 消费端具有一定的容灾能力，consumer 使用拉的方式从服务端获取消息，并且保存消费的具体位置，当消费者宕机之后恢复上线的时可以根据之前保存的消费位置重新拉取需要的消息进行消费，这样就不会造成消息的丢失。

分区中的所有副本通称为 AR（Assigned Replicas) 所有与 leader 副本保持一定程度同步的副本组成 ISR ,ISR 集合是 AR 集合的一个子集。消息会发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步，同步期间内 follower 副本相对于 leader 副本而言会有一定程度的滞后。滞后过多的副本组成 OSR,由此可以知道 AR = ISR + OSR，在正常情况下，所有的 follower 副本都应该与 leader 副本保持一定程度的同步，即AR=ISR，OSR集合为空。

leader 副本负责维护和跟踪 ISR 集合中所有 follower 副本的滞后状态，当follower 副本滞后太多的时候或者失效的时候，leader 副本会将其剔除。如果 OSR 中的 follower 集合追赶上 leader 副本，则leader 副本将其从 OSR 中转移到 ISR 中。

ISR 与HW 和 LED 有关系：

HW (High Watermark): 高水平位，它标识了一个特定的消息偏移量（offset），消费者只能拉取到这个 offset 之前的消息。

0 - 5 是可以消费的空间，此时 HW 为6，LEO 为9

![image-20190723205345034](/Users/maxu/MX-Notes/image/image-20190723205345034.png)

LEO (Log End Offset) : 标识当前日志文件中下一条待写入消息的 offset，LEO 的大小相当于当前日志分区中最后一条消息的 offset 值加 1。分区 ISR 集合中的每个副本都会维护自身的 LEO,而ISR 集合中最小的 LEO 即为分区的 HW，对消费者而言只能消费 HW 之前的消息。