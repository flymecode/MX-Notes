## Set

set代表一种集合元素无序，集合元素不可重复的集合。

HashSet的实现是基于HashMap的,它只是封装了一个HashMap对象来存储所有的集合元素。所有放入HashSet中的集合元素实际上由HashMap的key来保存，而HashMap的value则存储一个静态的Object对象。

```java
public HashSet() {
        map = new HashMap<>();
}
```



## Map

map是一种key-value对组成的集合。

Map集合是Set集合的扩展。

系统采用Hash算法决定集合元素的存储位置，这样可以保证快速存，取集合元素。

集合中保存的是对象的引用，并不是将Java对象放入set集合中。

## JDK1.7解读

```java
public V put(K key, V value) {
    if(key == null) {
        // 如果key为null，调用putForNullKey方法进行处理
       return putForNullKey(value); 
    }
    // 根据key的keyCode计算Hash值
    int hash = hash(key.hashCode());
    // 搜索指定hash值在对应table中的索引
    int i = indexFor(hash, table.length);
    // 如果i索引处的Entry不为null,通过循环不断遍历e元素的下一个元素。
    for(Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        // 找到指定key与需要放入的key相等
        if(e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    // 如果i索引处的Entry为null,表明此处还没有Entry
    modCount++;
    // 将key、value添加到i索引处
    addEntry(hash,key,value,i);
    return null;
}
```

从源码可以看出当试图将一个key-value对放入HashMap中时，首先根据该key的hashCode()返回值决定该Entry的存储位置：如果两个Entry的key的hashCode()返回值相同，那它们的存储位置相同；如果这两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有Entry的value,但是key不会覆盖，如果这两个key比较返回fase,新添加的Entry将与集合中原有的Entry形成Entry链，而且新添加的Entry位于Entry链的头部。

```java
void addEntry(int hash, K key, V value, int bucketIndex) {
    // 获取指定bucketIndex索引处的Entry
    Entry<K,V> e = table[bucketIndex];                  // 1
    // 将新创建的Entry放入bucketIndex索引处，并让新的Entry指向原来的Entry
    table[bucketIndex] = new Entry<K,V>(hash, key, value, e);
    // 如果Map中的key-value对的数量超过了极限
    // size: 保存HashMap中所包含的key-value数量
    // treshold: 包含了HashMap能容纳的key-value对的极限， 等于capacity * loadFactor
    if(size ++ >= threshold) {
        // 把table对象的长度扩容2倍
        resize(2 * table.length);
    }
}
```

将新添加的Entry对象放入table数组的bucketIndex索引处，如果bucketIndex索引处已经有一个Entry对象，新添加的Entry对象指向原有的Entry对象（产生一个Entry链），如果bucketIndex索引处没有Entry对象，也就是上面代码中1 行代码的e变量是null,即新放入的Entry对象指向null,就没有产生Entry链。

```java
// 指定初始化容量，负载因子创建HashMap 
public HashMap(int initialCapacity, float loadFactor) {
    	// 负载因子不能为负数
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
    	// 如果初始化容量大于最大容量，让初始化容量等于最大容量
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
    	// 负载因子必须是大于0的数
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
    
        this.loadFactor = loadFactor;
   		
    }

```

