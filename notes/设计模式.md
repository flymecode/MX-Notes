### 单例模式

#### 为什么会有单利设计模式？

单例模式主要是为了避免因为创建了多个实例造成资源的浪费，且多个实例由于多次调用容易导致结果的出错。而使用单例模式能够保证整个应用只有一个实例

#### 应用spring中`IOC`

在整个应用中（一般只用一个`IOC`容器），只创建Bean的一个实例，多次注入同一具体类时都是注入同一个实例。

`IOC`容器来实现过程简述如下：

​	当需要注入Bean时，`IOC`容器首先解析配置找到具体类，然后判断其作用域（@Scope注解）；

​	默认的单例@Scope(`ConfigurableBeanFactory.SCOPE_SINGLETON)`，则查找容器中之前有没有为其创建了Bean实例；如果有则直接注入该Bean实例，如果没有生成一个放到容器中保存

（`ConcurrentHashMap -- map.put(bean_id, bean)`），再注入。

`注：其中解析配置查找具体类、生成Bean实例和注入过程都是通过Java反射机制实现的。`

#### 解决的问题：

1. 可以保证一个类在内存中的对象的唯一性，在一些常用个工具类中，线程池，缓存和数据库，账号登陆系统，配置文件，等程序中之允许我们创建一个对象，
2. 如果创建多个对象会造成资源的严重浪费，也有可能会造成程序的错误。
3. 比如我们共享一个配置文件，当我们创建一个对象A修改其中的内容的时候，并不会真正改变类B.我们可能会想到把共享数据设置为静态数据。
4. 但是我们都知道静态数据的生命周期是很长的，假如`ConfigFile`中有很多数据时，如果将其全部设成静态的，那将是对内存的极大损耗。

#### 设计思想：

1. 不允许其它的程序用New对象
2. 在该类中创建对象
3. 对外提供一个可以让其他程序获取该对象的方法



①懒汉式

```java
/**
 @author maxu
 @date 2018/11/3
优点：从它的实现中我们可以看到，这种方式的实现比较简单，在类加载的时候就完成了实例化，避免了线程的同步
*	 问题。
缺点：由于在类加载的时候就实例化了，所以没有达到Lazy Loading(懒加载)的效果，也就是说可能我没有用到
*	  这个实例，但是它也会加载，会造成内存的浪费(但是这个浪费可以忽略，所以这种方式也是推荐使用的)。
*/
public class Singleton {

    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}  
```

②饿汉式

```java
public class Singleton {

    private static Singleton instance = null;
    private Singleton() {}
    public static Singleton getInstance() {
        if (null == instance) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

③双重校验锁

```java
public class Singleton {
    private static Singleton instance = null;

    private Singleton() {
    }

    public static synchronized Singleton getInstance() {
        if (null == instance) {
            synchronized (Singleton.class) {
                if (null == instance) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

}
```

④静态内部类

```java
/**
* 这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同
* 的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时
* 并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonHolder类，从而完成Singleton的实例化。
* 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的
* 优点：避免了线程不安全，延迟加载，效率高。
*/
public class Singleton {


    private Singleton() {
    }

    private static class Sinletonleader {
        private static Singleton singleton = new Singleton();
    }

    public Singleton getInstance() {
        return Sinletonleader.singleton;
    }
}
```

⑤枚举

```java
/**
* SingletonEnum.instance.method();
* 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，
* 而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中
* 很少见人这么写过，这种方式也是最好的一种方式，如果在开发中JDK满足要求的情况下建议使用这种方式。
*/
public enum Singleton {
    instance;

    private Singleton() {
    }

    public void method() {
    }
}
```



### 工厂设计模式

简单工厂模式：是由一个对象根据收到的消息决定要创建哪一个类的对象实例。

使用场景：工厂类负责创建的对象比较少，客户只需要传入工厂参数，对于如何创建对象不关心，违反了高内聚低耦合的原则。

最大的优点：工厂类包含了必要的逻辑根据用户的需要逻辑动态实例化相关的类。

缺点：只能生产同一级结构的产品，在添加新产品的时候需要修改代码

![img](https://app.yinxiang.com/shard/s71/res/706239cf-f66b-4f9a-aea7-c98650520e3b.png)



工厂方法模式：定义一个创建对象的工厂接口，让子类去决定实例化哪一个类，将实例化的工作延迟到子类当中。

场景：数据库访问的时候用户不知到最后系统采用那一个数据库以及数据库有什么变化。

特点：用来产生统一等级下结构的产品，支持增加任意的产品。





![img](https://app.yinxiang.com/shard/s71/res/70cb6788-f89e-4edd-a110-91af4fda67da.png)