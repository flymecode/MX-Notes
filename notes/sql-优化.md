[TOC]

## sql语句

### 基础命令

- ##### DISTINCT

可以对我们查询出来的字段进行去重操作，但是当我指定查询多个字段的时候DISTINCT对全部列起作用。

```sq
SELECT DISTINCT book_price FROM book;
```

```sql
SELECT DISTINCT book_price,book_name FROM book;
```



- ##### ORDER BY

为了明确的排序用SELECT语句检索出的数据，我们可以使用ORDER BY子句。

ORDER BY 子句可以取一个或者多个列的名字

默认是按照升序进行排序的ASC ，降序排序是按照 DESC 排序的。

```sql
SELECT book_name FROM book ORDER BY book_name;
```

```sql
SELECT book_name FROM book ORDER BY book_name,book_price;
```

`注意：`

​	`通常ORDER BY 子句使用的列将是我们显示所选择的列，但是我们也可使用非检索的列进项排序也是完全合法的。`

​	`当对多行进行排序的时候，首先会按照指定的排序规则进行，当按照第一个排序规则排序时，列中含有相同数值的时候，再按照第二个规则进行排序。如果第一个规则中所有列的值都唯一，就不会按照第二个规则进项排序，以此类推。`

- ##### LIMIT

默认是从第一行进行查询，行号为 0

```sql
SELECT * FROM book LIMIT 5; // 将返回最多5行数据，如果超出表的行数，将返回最多行。
```

```sql
SELECT * FROM book LIMIT 1,5; //从第2行返回最多5条数据
```

注意：在使用 ORDER BY 与 LIMIT的必须保证ORDER BY 必须在LIMIT 子句之前。

- ##### WHERE

`在同时使用WHERE 子句和OREDER BY子句的时候 必须保证ORDER BY 在后WHERE之后。`

- ##### BETWEEN 范围检查

```sql
SELECT * FROM book WHERE book_price BETWEEN 3 AND 5; // 包括开始值和结束值 3和5 
```

```sql
SELECT * FROM book WHERE book_price IS NULL;
```

- ##### IN

```sql
SELECT book_price FROM book WHERE book_price IN (1,2,3);
```

- ##### NOT

```sql
SELECT book_price FROM book WHERE book_price  NOT IN (1,2,3);
```

`注意：`

`NOT支持对BETWEEN IN EXISTS进行取反`



- ##### REGEXP 

进行正则匹配

```regexp
. 匹配任何字符
[123] 配置[]包含的字符
[1-2] 设置范围
'1000' 配置字符串
'1|2' 匹配1 或者 2
```



| 元字符 | 说明                       |
| :----- | -------------------------- |
| *      | 0个或者多个                |
| +      | 1个或者多个                |
| ？     | 0个或者一个                |
| {n}    | 指定个数                   |
| {n,}   | 不少于指定个数             |
| {n,m}  | 配置数目的范围，m不超过255 |

| 元字符 | 说明       |
| ------ | ---------- |
| ^      | 文本的开始 |
| $      | 文本的结束 |



### 聚集函数

------



- ##### AVG  

`忽略NULL`

- ##### COUNT 

`如果使用指定的列名，如果该列的值为空的时候会被忽略，如果是* 则不会忽略`

- ##### MAX  

`忽略NULL`

- ##### MIN  

`忽略NULL`



### 组合聚集函数

------



```sql
SELECT COUNT(*) AS num_items,MIN(prod_price) AS min,MAX(prod_price) AS price_max,AVG(prod_price) AS price_avg FROM products; 
```



### 分组数据

------



- ##### GROUP BY 

分组是在SELECT 与 GROUP BY 子句中建立的，如果想对分组进行过滤使用`HAVING` 子句

`HAVING`子句可以使用聚集函数，`WHERE`子句不能使用聚集函数



### 联接查询

- 内联接

  - 隐式内联接 ：使用不使用 `INNER JOIN` 子句，并使用`where`子句关联起来

  - ```sql
    select p.name, o.id from person as p , order as o where p.id = o.id;
    ```

  - 显示内联接：使用 `INNER JOIN子句` `并使用ON来关联表`

  - ```sql
    select p.name, o.id from person inner join order on p.id = o.id;
    ```

    `推荐使用 inner join 语法`

- 外联接 

  - 左外联接：`LEFT OUTER JOIN`
  - 右外联接：`RIGHT OUTER JOIN` 

  `当使用左外连接的时候，如果左表中在右表中对应的数据为NULL的话，可以在右表中以NULL的形式显示出来`



### 组合查询

- 在使用组合查询的条件有两种基本情况：

  - 在单个查询中从不同的返回类似的数据
  - 对单个表执行多个查询，按照单个查询返回数据

- ##### UNION

  ```sql
  SELECT vend_id,pro_id,pro_price FROM products WHERE pro_price < 5
  UNION
  SELECT vend_id,pro_id,pro_price FROM products WHERE vend_id IN (1,23,4);
  ```

  `UNION查询的列必须类型相同`

  `必须是两条或以上的SELECT语句`

  `UNION中的每个产需必须包含相同的列，表达式或聚集函数`

  `union自动多重复的行进行去重`



### SQL优化

​	执行子查询时，MySql需要建立临时表，查询完毕之后再删除这些临时表，所以，子查询的速度会受到一定的影响。

优化：可以使用连接查询 join 代替子查询，连接查询时不需要建立临时表，其速度比子查询快。

### 数据库结构优化

- 将字段很多的表分解成多个表，对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为一个表的数据量很大的时候，会由于使用频率低的字段存在而变慢

- 增加中间表

   对于需要经常联合查询的表，可以建立中间表，可以提高查询效率。

   通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为中间表查询。

- 增加冗余的字段
  设计数据表的时候尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来很精致，优雅。但

  是合理的加入冗余字段可以提高查询速度。

  对于冗余字段的设计，我们要根据不同的业务进行区分，一般来说对于数据改动比较少，而查询多的场景会使

  用冗余。	

  ##### 例如:

  用户名称字段name本来属于表user，表示”用户昵称”的字段就唯一的只应该属于user表的”name”字段，当用

  户要修改昵称的时候，程序就只需要修改 user.name字段。但是在其他数据表(比如订单orders表)里只存储了

  用户的ID，我要通过这个ID值得到用户昵称该怎么办呢？一个普遍的解决方法是通过联接(join)查询通过ID这

  个唯一条件联接两个表，从而取到用户的昵称。

  这样确实是没问题，我也一直觉得这样是最好的方案，扩展方便，当要更新用户信息时，程序中要修改的地方

  很少，但是随着数据库里数据不断增加，百万，千万，同时，用户表的数据肯定也在不断的增加的，它可能是

  十万，百万。这个时候，你会发现两个表通过联接来取数据就显得相当费力了，可能你只需要取一个name这

  个用户昵称属性，你就不得不去联接查询一下那个已经几十万的用户表进行检索，其速度自然变得非常慢。

  所以我们这个时候可以将用户的name字段保存到订单表中，这样当我们查询订单列表的时候，对于用户名称

  我们就可以不用联接查询，但是冗余字段的值在一个表中修改了，就要想办法在其他的表中更新，否则将会导

  致数据不一致的问题。所以也增加了维护的开销。

### 插入数据的优化

插入数据的时候，影响插入速度的主要是索引，唯一性校验，一次插入多条数据等。

插入数据的优化，不同的存储引擎优化手段不一样，在MySQL中常用的存储引擎有MyISAM和InnoDB

##### 两者的区别主要有：

MyISAM是MySQL5.5之前默认的搜索引擎，目前MySQL的默认搜索引擎是InnoDB，基于传统 MyISAM 类型，支持全文搜索，但不是事务安全的，而且不支持外键，每张 MyISAM 表存放在三个文件中。

InnoDB是事务型引擎，支持回滚，多版本并发控制，ACID事务，支持行级锁定

### 主要区别

- MyISAM是非事务安全的，而InnoDB是事务安全的。
- MyISAM锁的粒度是表级，而InnoDB支持行级锁定。
- MyISAM支持全文类型索引，而InnoDB不支持全文索引。
- MyISAM相对简单，在执行效率上要优于InnoDB，小型应用可以考虑使用MyISAM。
- MyISAM表是保存文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。
- InnoDB表比MyISAM表更安全，可以保证数据不会丢失的情况下，切换非事务表到事务表。

### 禁用索引

​	对于非空表，插入记录时，MySQL会根据表的索引对插入的记录建立索引。如果插入大量数据，建立索引会降低插入数据速度。

​	为了解决这个问题，可以在批量插入数据之前禁用索引，数据插入完成后再开启索引。

- 禁用索引的语句：

```sql
ALTER TABLE table_name DISABLE KEYS
```

- 开启索引语句：

```sql
ALTER TABLE table_name ENABLE KEYS
```

对于空表批量插入数据，则不需要进行操作，因为MyISAM引擎的表是在导入数据后才建立索引。

### 禁用唯一性检查

- 唯一性校验会降低插入记录的速度，可以在插入记录之前禁用唯一性检查，插入数据完成后再开启。
- 禁用唯一性检查的语句：`SET UNIQUE_CHECKS = 0;`
- 开启唯一性检查的语句：`SET UNIQUE_CHECKS = 1;`

### 索引失效的场景

- 使用like关键字的查询

  在使用like关键字进行查询的查询语句中，如果匹配第一个字符串为%，索引不起作用，只有%不在第一个位置，索引才会起作用。

- 使用联合查询索引的查询

  MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于联合索引，只有查询条件中使用了这些字段中第一个字段时，索引才会生效。

- 使用OR关键字的查询

  查询语句的查询条件中只有OR关键字，并且OR前后的两个条件中的列都是索引时，索引才会生效，否则，索引不生效

子查询优化为连接查询，对于一对多的关系要使用distinct去重

group by 的优化，最好使用同一表中的列，这中优化后的方式没有使用临时文件和文件排序的方式。

limit的优化查询，使用索引列或主键列进行order by 

记录上次返回的主键，在下次查询的时候使用主键过滤。避免数据量大的时候扫描过多的记录。

##### 什么情况下，使用索引了？

1、表的主关键字

2、自动建立唯一索引

3、表的字段唯一约束

4、直接条件查询的字段（在SQL中用于条件约束的字段）

5、查询中与其它表关联的字段

6、查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）

7、查询中统计或分组统计的字段

8、表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）

9、经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）

10、数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）

11、经常和主字段一块查询但主字段索引值比较多的表字段

12、对千万级MySQL数据库建立索引的事项及提高性能的手段

### 数据库索引新建原则有那些？

1. 具有唯一性的属性必须增加唯一约束，与唯一索引
2. 在where从句，group by从句，order by从句，on从句中的列添加索引
3. 如果属性是大的文本不要增加索引
4. 字符串类型的索引需要指定长度，尽量使用前缀来增加索引
5. 经常会被join联合查询的外键需要增加索引
6. 一张表不要增加太多的索引
7. 索引应该加在区分度比较高的属性上面
8. 不经常使用，或者很少使用的索引要删除掉
9. 使用唯一索引会锁表
10. 索引字段越小越好（因为数据库数据存储单位是以“页”为单位的，数据存储的越多，IO也会越大）

![1557949286438](E:\Git\TTMS\MX-Notes\image\1557949286438.png)

![1557949292655](E:\Git\TTMS\MX-Notes\image\1557949292655.png)