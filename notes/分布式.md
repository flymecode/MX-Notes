# 一、分布式锁

在单机引用中我们使用语言内置的锁来实现同步，但是在分布式场景下，我们需要同步的进程位于不同的节点上，那么就需要分布式锁。

阻塞锁通常使用互斥量来实现：

- 互斥量为0,代表有其它的进程来使用锁，此时处于锁定的状态。
- 互斥量为1,没有进程获取锁。

1和0可以用一个整型值，来表示，也可以用某个数据是否存在表示。

# 数据库的唯一索引

获得锁时向数据库中插入一条记录，释放锁的时候释放这条记录。唯一索引可以保证该记录只能被插入一次，那么就可以用这条记录是否存在判断是否存于锁定状态。

存在以下问题：

- 锁不可重入，已经获得锁的进程也必须重新获取锁
- 只能是非阻塞锁，插入失败直接就报错了，无法重试。
- 锁没有失效的时间，解锁失败的话其它进程无法再获得该锁。

# Redis 的SETNX 指令

使用SETNX指令插入一个键值对，如果Key已经存在，直接返回false,否则返回为True

SETNX指令和数据库中的唯一索引很像，保证了只存在一个Key的键值对,可以使用一个Key的键值对来判断是否存在锁定状态。

EXPIRE指令可以为一个键值对设置过期时间，从而避免数据库唯一索引实现方式中释放失败的问题。

# Redis的RedLock算法

使用多个redis实例来实现分布式锁，这是为了保证在发生单点故障的时候还可以使用。

- 尝试从N个相互独立的Redis实例中获取锁；
- 计算获取锁消耗的时间，只有当这个时间小与锁的过期时间，并且从大多数（N/2+1）实例上获取了锁，那么就认为锁获取成功了；
- 如果锁获取失败，就到每个实例上释放锁。



# 二、分布式事务

指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。

例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。

## 本地消息表

本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。

1. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
2. 之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
3. 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。

