# Redis

[TOC]



## 数据类型



### String

- 比如说 ，我想知道什么时候封锁一个IP地址。Incrby命令

- 计数器，可以对String进行自增自减运算，从而实现计数器功能。

  Redis这种内存数据库模型的读写性能非常高，很适合存储频繁的读写计数量

### Hash

- 存储用户信息（id，name，age）

  Hset(key,field,value)

  Hset(userKey,id,101)

  Hset(userKey,name,admin)

  Hset(userKey,age,23)

​	Hget(userKey,id)

​	Hset(userKey,id,102)

为什么不使用String 类型来存储？

​	Set(userKey,用信息的字符串)

​	Get(userKey)

​	不建议使用String 类型

### List

- 实现最新消息的排行，还可以利用List的push命令，将任务存在list集合中，同时使用另一个命令，将任务从集合中取出[pop]。
- List是一个双向链表的结构，可以模拟消息队列。不过最好使用RabbitMQ【电商中的秒杀就可以采用这种方式来完成一个秒杀活动】

### Set

- 特殊之处：可以自动排重。比如说微博中将每个人的好友存在集合(Set)中，这样求两个人的共通好友的操作。我们只需要求交集即可。

### ZSet

- 以某一个条件为权重，进行排序。

- 京东：商品详情的时候，都会有一个综合排名，还可以按照价格进行排名。

## 数据结构



### 字典

- dictht 是一个散列表的结构，使用拉链法保存哈希冲突。

  ```c
  typedef struct dictht {
      dictEntry **table;
      unsigned long size;
      unsigned long sizemask;
      unsigned long used;
  } dictht;
  typedef struct dictEntry {
      void *key;
      union {
          void *val;
          uint64_t u64;
          int64_t s64;
          double d;
      } v;
      struct dictEntry *next;
  } dictEntry;
  ```

- Redis的字典dict中包含两个dictht，这是为了方便进行rehash操作。在扩容的时候，讲一个dictht上的键值对rehash到另外一个dictht上面，完成之后释放空间并交换两个dictht的角色。

- rehash操作不是一次性完成的，而是采用渐进的方式，这是为了避免一次行执行过多的rehash操作给服务器带来过大的负担。

- 渐进式rehash通过记录dict的rehashidx完成，它从0开始，然后每执行一次rehash都会递增。例如在一次rehash中，把dict[0] rehash到dict[1],这一次会把dict[0] 上table[rehashidx] 的键值对rehash到dict[1]上，dict[0]的table[rehashidx]指向null,并令rehashidx++。

- 在rehash期间，每次对字典执行添加、删除、查找或者更新操作时候，都会执行一次渐进式rehash。

- 渐进式rehash会导致字典中的数据分散在两个dictht上，因此对字典的查找操作也需要到对应的dictht去执行。

### 跳跃表

是有序集合的底层实现之一。

跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。

在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。

与红黑树相比，跳跃表有以下的有点：

- 插入速度非常的快速，因为不需要进行旋转操作维护平衡性
- 更容易实现
- 支持无锁操作
- 

## 数据持久化



### RDB

-   在指定的时间间隔内的内存中的所有数据以快照的方式写入磁盘，恢复时就将快照文件直接读到内存中
-   会创建一个子进程来进行持久化，先将数据写入一个临时文件中，等持久化都结束之再用这个临时文件替换上次的持久化文件，在整个过程中主进程是不进行IO操做的
-   优点：节省磁盘空间恢复速度快 
-   缺点：比较浪费性能,最后一次持久化之后的数据可能丢失，如果数据量很大，保存快照的时间会很长。
-   redis 中的更新次数只是一个阈值，不是绝对的更新次数，由 serverCorn 来检查是在特定的时间内满足大于等于设定的数值。

### AOF

- 将写命令添加到AOF文件的末尾
- 优点：备份机制稳定，丢失数据概率更低，可读的日志文本  
- 缺点：占用更多的磁盘空间，每次读写都是同步的，有一定的性能压力。恢复速度比较慢

使用AOF持久化开启的时候，文件的载入优先于RDB文件

使用AOF持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。

always每个写命令都会同步，会严重降低服务起的性能。

everysec每秒同步一次，选项比较合适，可以保证系统崩溃的时候只会丢失一秒左右的数据，并且Redis每秒执行一次同步对服务器性能几乎没有任何影响。

no 让操作系统来决定什么时候同步，不能给服务器带来很大的提升，而且也会增大系统崩溃时候数据丢失。

随着服务器的写命令的增对，AOF文件会越来越大，Redis提供了一种AOF重写的特性，能够去除AOF文件中冗余的写命令。

AOF持久化功能的实现分为命令的追加，文件写入，文件同步，执行的写命令首先被追加在服务器的 aof_buf 缓冲池区的末尾。

Redis 的服务进程就是一个事件循环，这个循环中文件事件负责接受客户端发来命令，并返回响应的命令恢复。时间事件是定时运行一些函数。因为服务器在处理文本事件的时候，可能会执行写命令，并使得一些内容被添加到缓冲区中，所以在服务器每次结束一个循环之前，都会考虑调用 flushAppendOnlyFile 函数是不是要将 aof_buf 中的内容写入和保存到 AOF 文件中。flushAppendOnlyFile 函数的行文会根据服务器配置的 appednfsync 选项的值来决定。

服务器首先会将 aof_buf 中的内容写入到 OS Cache 中，然后再进行同步，从OS Cache 中同步到本地磁盘文件中。

AOF 文件载入的时候，Redis 服务器首先创建一个 fake client 客户端，来从 AOF 文件中循环取出写命令进行执行。

AOF 重写为了解决文件体积膨胀的问题，创建一个新的 AOF 文件来替代现有的 AOF 文件，新旧两个 AOF 文件所保存的数据库状态相同，但是新的 AOF 文件不会包含任何浪费冗余的命令。AOF 文件重写并不需要对现有的 AOF

文件进行读取，分析，写入的操作，这个功能是通过对读取服务器当前数据库状态来实现的。首先从数据库中读取现有键值对现在的值，然后用一条写命令去记录键值对，代替之前记录这个键值对的多条命令，这就是 AOF 重写功能的实现原理。



Redis 是单线程来处理客户端的请求，如果重写函数进行大量写入操作的时候会长时间阻塞，这时候服务器无法处理客户端的发来的命令请求，所以决定将重写函数放在一个子进程中去处理，一方面子进程在重写的时候，父进程可以继续处理命令。

子进程带有服务器进程的数据副本，使用子进程而不是线程，可以避免使用锁的情况下保证数据的安全。

但是子进程进行处理的时候，父进程还在执行命令，可能对现有的数据库状态进行修改。从而使得数据库状态和重写后的状态不一致。所以在 Redis 中设置了一个 AOF 重写缓冲池，这个缓冲池在服务器创建子进程的时候使用，当Redis 服务器执行完一个写命令之后，会同时将这个写命令发送给 AOF 缓冲区 



## 事物

一个事务包含了多个写命令，服务器在执行事务期间，不会改去执行其他客户端的请求。

事务中的多个写命令被一次性的发送给服务器，而不是一条一条的发送，这种方式被称为流水线，它可以减少客户端与服务端之间的网络通信次数从而提升性能。

Redis最简单的事务实现方式是使用MULTI和EXEC命令将事务包围起来。

## 事件

Redis服务器是一个事件驱动程序。 文本事件和时间时间

文件事件和时间时间是合作关系，服务器会轮流处理这两种事件。  

![1555763934732](E:\Git\TTMS\MX-Notes\image\1555763934732.png)

### 文件事件

服务器通过套接字与客户端或者其他服务器进行通信，文件事件就是对套接字操作的抽象。

Redis基于Reactor 模式开发了自己的网路事件处理器，使用I/O多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，文件分派器会根据套接字产生的事件类型调用相应的事件处理器。

尽管多个文件事件可以并发的出现，但是在底层这些事件被顺序的放入一个队列中，顺序、同步的执行。

I/O 多路复用器可以监听多个套接字的可读和可写事件。如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。

 ![1555763956536](E:\Git\TTMS\MX-Notes\image\1555763956536.png)

### 时间事件

服务器有一些操作需要在给定的时间点执行，时间事件是对类定时的操作抽象。

时间事件又分为：

- 定时事件：是让一段程序在指定的时间之内执行一次
- 周期性事件：是让一段程序每隔指定时间就执行一次

Redis将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应事件处理器。

服务器一般情况下只执行 serverCron 函数一个时间事件。并且这个事件是周期性事件。



## 复制

通过使用slaveof host port 命令来让一个服务器成为另一服务器的从服务器。

一个从服务器只能有一个主服务器，并且不支持主从复制。

### 连接过程

1. 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲去记录执行的写命令，快照文件发送完毕之后，开始向从服务器发送存储缓冲区中的写命令。
2. 从服务器丢弃旧的数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令。
3. 主服务器每次执行一次写命令，就向从服务器发送相同的写命令。

### 主从链

随着负载的不断上升，主服务器可能无法很快的更新从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题我们可以建立一个中间层来分担主服务器的复制工作。中间服务层的服务器是最上层的从服务器，又是最下层服务器的主服务器。



### Sentinel

哨兵监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选择新的主服务器。



## 分片

假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。

- 最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。
- 还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。

根据执行分片的位置，可以分为三种分片方式：

- 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。
- 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
- 服务器分片：Redis Cluster。

## 键的过期时间

Redis可以为每个键设置过期时间，每当键过期时，会自动删除该键。

对于散列表这种容器，只能为整个键设置过期时间，而不能为键里面的单个元素设置过期时间。

## 数据淘汰策略

可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。

Redis 具体有 6 种淘汰策略：

| 策略            | 描述                                                 |
| --------------- | ---------------------------------------------------- |
| volatile-lru    | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
| volatile-ttl    | 从已设置过期时间的数据集中挑选将要过期的数据淘汰     |
| volatile-random | 从已设置过期时间的数据集中任意选择数据淘汰           |
| allkeys-lru     | 从所有数据集中挑选最近最少使用的数据淘汰             |
| allkeys-random  | 从所有数据集中任意选择数据进行淘汰                   |
| noeviction      | 禁止驱逐数据                                         |

作为内存数据，处于对性能和内存消耗的考虑，Redis的淘汰算法实际实现上并非针对所有的key,而是抽样一小部分并且从中选出被淘汰的key

使用redis缓存数据时候，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用allkeys-lru淘汰策略，将最近少的数据淘汰。

## 常见问题

缓存穿透

​	缓存穿透是指查询一个数据库一定不存的数据。正常的使用缓存流程大致是，数据查询先查询缓存，如果key不存或者key已经过期，在对数据库进行查询，并把查询到的对象放入缓存中。如果数据库查询对象为空，则不放进缓存。

![img](E:\Git\TTMS\MX-Notes\image\u=3117417475,1030280178&fm=173&app=49&f=JPEG.jpg)

如果出现这个情况，如果传入的参数为-1，会是怎么样呢？这个-1，就是一定不存的对象，就会每次都去查询数据库，而每次查询都是空，每次由都不会进行缓存。如果有恶意攻击，对数据库造成压力，甚至会压垮数据库。即便是采用UUID，也很容易找到一个不存的Key，进行攻击。

解决方式：

- 采用缓存空值的方式，如果从数据库查询到对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。

![img](E:\Git\TTMS\MX-Notes\image\u=779177724,27899716&fm=173&app=49&f=JPEG.jpg)

- 布隆过滤器

  ```java
  
  public String getByKey(String key) {
      // 通过key获取value
      String value = redisService.get(key);
      if (StringUtil.isEmpty(value)) {
          if (bloomFilter.mightContain(key)) {
              value = userService.getById(key);
              redisService.set(key, value);
              return value;
          } else {
              return null;
          }
      }
      return value;
  }
  ```

  

  对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃。还有最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

### 缓存雪崩

​	缓存雪崩，是指在某一段时间，缓存集中过期失效。

​	产生雪崩的原因之一，就是一段时间集中放入缓存，如果缓存集中过期，在缓存上都无法命中数据，所有的查询都落在数据库上，对数据库而言，就会产生周期性的压力波峰。

解决方案：

- 对不同类别，缓存不同的周期，在同一类别上的商品上加上一个随机因子，这样就可以分散的缓存过期时间，而且，热门类目的商品缓存时间长一点，冷门类目的商品缓存时间短一点，也能节省缓存服务的资源。
- 做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。
- 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待

其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，那么那个时候数据库能顶住压力，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。

### 缓存击穿

- 缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在屏障上开了一个洞。

- ###### 对于这样的热点数据，我们可以把他们呢设置为永不过期就好。



### 为何用Redis而不用map做缓存？

缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的本地缓存，最主要的特点是轻量快速，生命周期随着JVM的销毁而结束，并且在多个实例的情况下，每个实例都需要保存一份缓存，缓存不具有一致性。

使用redis称为分布式缓存，在多个实例的情况下，各个实例公用一份缓存数据，缓存具有一致性。缺点是需要保持redis服务的高可用，整个程序架构上复杂。

redis可以独立不熟，这样网站代码更新后redis缓存的数据还在，本地内存每次网站更新都会释放掉数据存到redis中，多个项目间可以共享缓存数据，如果是本地内存是无法跨项目共享的。

本地缓存不容易查看，以及修改redis有丰富的工具来进行管理。

redis可以用更大的内存空间做缓存，map不行，一般JVM也就分几个G的数据就够大了。

redis的缓存可以持久化，map是内存对象，程序一重新启动就没有了

redis可以处理每秒百万级的并发，是专业的缓存服务，map只是一个普通的对象

redis缓存有过期的机制，map本身没有此功能。

redis有丰富的API,map简单

reodis可以实现分布式部署，只要涉及到多台进程啥的，map就实现不了

redis有很多数据结构，方便操作。

如果你缓存的东西太多，容易让JVM挂掉。

reids是C语言写的，稳定性和性能更好。



## Client

- 服务器状态接口是使用clients 链表来凝结起来多个客户端状态，新添加的客户端状态会被放到链表的尾部。

- 客户端状态的 flags 属性使用不同的标志来表示客户端的角色，以及客户端的状态。

- 输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过 1GB

- 客户端有两个输入缓冲区，用来保存服务端对命令的响应。一个是可变的，另外一个是不可变的。

  

 

