### Redis使用场景

##### String

- 比如说 ，我想知道什么时候封锁一个IP地址。Incrby命令

##### Hash

- 存储用户信息（id，name，age）

  Hset(key,field,value)

  Hset(userKey,id,101)

  Hset(userKey,name,admin)

  Hset(userKey,age,23)

​	Hget(userKey,id)

​	Hset(userKey,id,102)

###### 为什么不使用String 类型来存储

​	Set(userKey,用信息的字符串)

​	Get(userKey)

​	不建议使用String 类型

##### List

- 实现最新消息的排行，还可以利用List的push命令，将任务存在list集合中，同时使用另一个命令，将任务从集合中取出[pop]。
- Redis—list数据类型来模拟消息队列。【电商中的秒杀就可以采用这种方式来完成一个秒杀活动】

##### Set

- 特殊之处：可以自动排重。比如说微博中将每个人的好友存在集合(Set)中，这样求两个人的共通好友的操作。我们只需要求交集即可。

##### ZSet

- 以某一个条件为权重，进行排序。

- 京东：商品详情的时候，都会有一个综合排名，还可以按照价格进行排名。



#### RDB

-   在指定的时间间隔内将内存中的所有数据以快照的方式写入磁盘，恢复时就将快照文件直接读到内存中

-   会创建一个子进程来进行持久化，先将数据写入一个临时文件中，等持久化都结束之再用这个临时文件替换上次的持久化文件，在整个过程中主进程是不进行IO操做的
-   优点：节省磁盘空间恢复速度快 
-   缺点：比较浪费性能,最后一次持久化之后的数据可能丢失

#### AOF

- 以日志的方式来记录每个写操作。只是追加文件

- 优点：备份机制稳定，丢失数据概率更低，可读的日志文本  
- 缺点：占用更多的磁盘空间，每次读写都是同步的，有一定的性能压力。恢复速度比较慢



#### 缓存穿透

​	缓存穿透是指查询一个数据库一定不存的数据。正常的使用缓存流程大致是，数据查询先查询缓存，如果key不存或者key已经过期，在对数据库进行查询，并把查询到的对象放入缓存中。如果数据库查询对象为空，则不放进缓存。

![img](E:\Git\TTMS\MX-Notes\image\u=3117417475,1030280178&fm=173&app=49&f=JPEG.jpg)

如果出现这个情况，如果传入的参数为-1，会是怎么样呢？这个-1，就是一定不存的对象，就会每次都去查询数据库，而每次查询都是空，每次由都不会进行缓存。如果有恶意攻击，对数据库造成压力，甚至会压垮数据库。即便是采用UUID，也很容易找到一个不存的Key，进行攻击。

##### 解决方式

- 采用缓存空值的方式，如果从数据库查询到对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。

![img](E:\Git\TTMS\MX-Notes\image\u=779177724,27899716&fm=173&app=49&f=JPEG.jpg)

- 布隆过滤器

  ```java
  
  public String getByKey(String key) {
      // 通过key获取value
      String value = redisService.get(key);
      if (StringUtil.isEmpty(value)) {
          if (bloomFilter.mightContain(key)) {
              value = userService.getById(key);
              redisService.set(key, value);
              return value;
          } else {
              return null;
          }
      }
      return value;
  }
  ```

  

  对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃。还有最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

#### 缓存雪崩

​	缓存雪崩，是指在某一段时间，缓存集中过期失效。

​	产生雪崩的原因之一，就是一段时间集中放入缓存，如果缓存集中过期，在缓存上都无法命中数据，所有的查询都落在数据库上，对数据库而言，就会产生周期性的压力波峰。

##### 解决方案：

- 对不同类别，缓存不同的周期，在同一类别上的商品上加上一个随机因子，这样就可以分散的缓存过期时间，而且，热门类目的商品缓存时间长一点，冷门类目的商品缓存时间短一点，也能节省缓存服务的资源。
- 做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。
- 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待

其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，那么那个时候数据库能顶住压力，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。

#### 缓存击穿

- 缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在屏障上开了一个洞。
- 对于这样的热点数据，我们可以把他们呢设置为永不过期就好。