# Redis使用场景

## String

- 比如说 ，我想知道什么时候封锁一个IP地址。Incrby命令

- 计数器，可以对String进行自增自减运算，从而实现计数器功能。

  Redis这种内存数据库模型的读写性能非常高，很适合存储频繁的读写计数量

### Hash

- 存储用户信息（id，name，age）

  Hset(key,field,value)

  Hset(userKey,id,101)

  Hset(userKey,name,admin)

  Hset(userKey,age,23)

​	Hget(userKey,id)

​	Hset(userKey,id,102)

###### 为什么不使用String 类型来存储

​	Set(userKey,用信息的字符串)

​	Get(userKey)

​	不建议使用String 类型

### List

- 实现最新消息的排行，还可以利用List的push命令，将任务存在list集合中，同时使用另一个命令，将任务从集合中取出[pop]。
- List是一个双向链表的结构，可以模拟消息队列。不过最好使用RabbitMQ【电商中的秒杀就可以采用这种方式来完成一个秒杀活动】

### Set

- 特殊之处：可以自动排重。比如说微博中将每个人的好友存在集合(Set)中，这样求两个人的共通好友的操作。我们只需要求交集即可。

### ZSet

- 以某一个条件为权重，进行排序。

- 京东：商品详情的时候，都会有一个综合排名，还可以按照价格进行排名。

# 数据结构

### 字典

- dictht 是一个散列表的结构，使用拉链法保存哈希冲突。

  ```c
  typedef struct dictht {
      dictEntry **table;
      unsigned long size;
      unsigned long sizemask;
      unsigned long used;
  } dictht;
  typedef struct dictEntry {
      void *key;
      union {
          void *val;
          uint64_t u64;
          int64_t s64;
          double d;
      } v;
      struct dictEntry *next;
  } dictEntry;
  ```

- Redis的字典dict中包含两个dictht，这是为了方便进行rehash操作。在扩容的时候，讲一个dictht上的键值对rehash到另外一个dictht上面，完成之后释放空间并交换两个dictht的角色。

- rehash操作不是一次性完成的，而是采用渐进的方式，这是为了避免一次行执行过多的rehash操作给服务器带来过大的负担。

- 渐进式rehash通过记录dict的rehashidx完成，它从0开始，然后每执行一次rehash都会递增。例如在一次rehash中，把dict[0] rehash到dict[1],这一次会把dict[0] 上table[rehashidx] 的键值对rehash到dict[1]上，dict[0]的table[rehashidx]指向null,并令rehashidx++。

- 在rehash期间，每次对字典执行添加、删除、查找或者更新操作时候，都会执行一次渐进式rehash。

- 渐进式rehash会导致字典中的数据分散在两个dictht上，因此对字典的查找操作也需要到对应的dictht去执行。

### 跳跃表

是有序集合的底层实现之一。

跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。

在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。

与红黑树相比，跳跃表有以下的有点：

- 插入速度非常的快速，因为不需要进行旋转操作维护平衡性
- 更容易实现
- 支持无锁操作

### 数据持久化



#### RDB

-   在指定的时间间隔内的内存中的所有数据以快照的方式写入磁盘，恢复时就将快照文件直接读到内存中

-   会创建一个子进程来进行持久化，先将数据写入一个临时文件中，等持久化都结束之再用这个临时文件替换上次的持久化文件，在整个过程中主进程是不进行IO操做的
-   优点：节省磁盘空间恢复速度快 
-   缺点：比较浪费性能,最后一次持久化之后的数据可能丢失，如果数据量很大，保存快照的时间会很长。

#### AOF

- 将写命令添加到AOF文件的末尾
- 优点：备份机制稳定，丢失数据概率更低，可读的日志文本  
- 缺点：占用更多的磁盘空间，每次读写都是同步的，有一定的性能压力。恢复速度比较慢

使用AOF持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。

always每个写命令都会同步，会严重降低服务起的性能。

everysec每秒同步一次，选项比较合适，可以保证系统崩溃的时候只会丢失一秒左右的数据，并且Redis每秒执行一次同步对服务器性能几乎没有任何影响。

no 让操作系统来决定什么时候同步，不能给服务器带来很大的提升，而且也会增大系统崩溃时候数据丢失。

随着服务器的写命令的增对，AOF文件会越来越大，Redis提供了一种AOF重写的特性，能够去除AOF文件中冗余的写命令。

### 事物

一个事务包含了多个写命令，服务器在执行事务期间，不会改去执行其他客户端的请求。

事务中的多个写命令被一次性的发送给服务器，而不是一条一条的发送，这种方式被称为流水线，它可以减少客户端与服务端之间的网络通信次数从而提升性能。

Redis最简单的事务实现方式是使用MULTI和EXEC命令将事务包围起来。

# 事件

Redis服务器是一个事件驱动程序。

## 文件事件

服务器通过套接字与客户端或者其他服务器进行通信，文件事件就是对套接字操作的抽象。

Redis基于Reactor 模式开发了自己的网路事件处理器，使用I/O多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，文件分派器会根据套接字产生的事件类型调用相应的事件处理器。



### 时间事件

服务器有一些操作需要在给定的时间点执行，时间事件是对类定时的操作抽象。

时间事件又分为：

- 定时事件：是让一段程序在指定的时间之内执行一次
- 周期性事件：是让一段程序每隔指定时间就执行一次

Redis将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应事件处理器。



# 复制

通过使用slaveof host port 命令来让一个服务器成为另一服务器的从服务器。

一个从服务器只能有一个主服务器，并且不支持主从复制。

### 连接过程

1. 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲去记录执行的写命令，快照文件发送完毕之后，开始向从服务器发送存储缓冲区中的写命令。
2. 从服务器丢弃旧的数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令。
3. 主服务器每次执行一次写命令，就向从服务器发送相同的写命令。

### 主从链

随着负载的不断上升，主服务器可能无法很快的更新从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题我们可以建立一个中间层来分担主服务器的复制工作。中间服务层的服务器是最上层的从服务器，又是最下层服务器的主服务器。



### Sentinel

哨兵监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选择新的主服务器。



### 分片

假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。

- 最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。
- 还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。

根据执行分片的位置，可以分为三种分片方式：

- 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。
- 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
- 服务器分片：Redis Cluster。



### 键的过期时间

Redis可以为每个键设置过期时间，每当键过期时，会自动删除该键。

对于散列表这种容器，只能为整个键设置过期时间，而不能为键里面的单个元素设置过期时间。

### 数据淘汰策略

可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。

Redis 具体有 6 种淘汰策略：

| 策略            | 描述                                                 |
| --------------- | ---------------------------------------------------- |
| volatile-lru    | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
| volatile-ttl    | 从已设置过期时间的数据集中挑选将要过期的数据淘汰     |
| volatile-random | 从已设置过期时间的数据集中任意选择数据淘汰           |
| allkeys-lru     | 从所有数据集中挑选最近最少使用的数据淘汰             |
| allkeys-random  | 从所有数据集中任意选择数据进行淘汰                   |
| noeviction      | 禁止驱逐数据                                         |

作为内存数据，处于对性能和内存消耗的考虑，Redis的淘汰算法实际实现上并非针对所有的key,而是抽样一小部分并且从中选出被淘汰的key

使用redis缓存数据时候，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用allkeys-lru淘汰策略，将最近少的数据淘汰。

#### 缓存穿透

​	缓存穿透是指查询一个数据库一定不存的数据。正常的使用缓存流程大致是，数据查询先查询缓存，如果key不存或者key已经过期，在对数据库进行查询，并把查询到的对象放入缓存中。如果数据库查询对象为空，则不放进缓存。

![img](E:\Git\TTMS\MX-Notes\image\u=3117417475,1030280178&fm=173&app=49&f=JPEG.jpg)

如果出现这个情况，如果传入的参数为-1，会是怎么样呢？这个-1，就是一定不存的对象，就会每次都去查询数据库，而每次查询都是空，每次由都不会进行缓存。如果有恶意攻击，对数据库造成压力，甚至会压垮数据库。即便是采用UUID，也很容易找到一个不存的Key，进行攻击。

###### 解决方式

- 采用缓存空值的方式，如果从数据库查询到对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。

![img](E:\Git\TTMS\MX-Notes\image\u=779177724,27899716&fm=173&app=49&f=JPEG.jpg)

- 布隆过滤器

  ```java
  
  public String getByKey(String key) {
      // 通过key获取value
      String value = redisService.get(key);
      if (StringUtil.isEmpty(value)) {
          if (bloomFilter.mightContain(key)) {
              value = userService.getById(key);
              redisService.set(key, value);
              return value;
          } else {
              return null;
          }
      }
      return value;
  }
  ```

  

  对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃。还有最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

#### 缓存雪崩

​	缓存雪崩，是指在某一段时间，缓存集中过期失效。

​	产生雪崩的原因之一，就是一段时间集中放入缓存，如果缓存集中过期，在缓存上都无法命中数据，所有的查询都落在数据库上，对数据库而言，就会产生周期性的压力波峰。

##### 解决方案：

- 对不同类别，缓存不同的周期，在同一类别上的商品上加上一个随机因子，这样就可以分散的缓存过期时间，而且，热门类目的商品缓存时间长一点，冷门类目的商品缓存时间短一点，也能节省缓存服务的资源。
- 做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。
- 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待

其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，那么那个时候数据库能顶住压力，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。

#### 缓存击穿

- 缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在屏障上开了一个洞。

- ###### 对于这样的热点数据，我们可以把他们呢设置为永不过期就好。



### 为何用Redis而不用map做缓存？

缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的本地缓存，最主要的特点是轻量快速，生命周期随着JVM的销毁而结束，并且在多个实例的情况下，每个实例都需要保存一份缓存，缓存不具有一致性。

使用redis称为分布式缓存，在多个实例的情况下，各个实例公用一份缓存数据，缓存具有一致性。缺点是需要保持redis服务的高可用，整个程序架构上复杂。

redis可以独立不熟，这样网站代码更新后redis缓存的数据还在，本地内存每次网站更新都会释放掉数据存到redis中，多个项目间可以共享缓存数据，如果是本地内存是无法跨项目共享的。

本地缓存不容易查看，以及修改redis有丰富的工具来进行管理。

redis可以用更大的内存空间做缓存，map不行，一般JVM也就分几个G的数据就够大了。

redis的缓存可以持久化，map是内存对象，程序一重新启动就没有了

redis可以处理每秒百万级的并发，是专业的缓存服务，map只是一个普通的对象

redis缓存有过期的机制，map本身没有此功能。

redis有丰富的API,map简单

reodis可以实现分布式部署，只要涉及到多台进程啥的，map就实现不了

redis有很多数据结构，方便操作。

如果你缓存的东西太多，容易让JVM挂掉。

reids是C语言写的，稳定性和性能更好。







#### 