[TOC]



## 操作系统

### 基本特征

#### 1.并发

在多道程序环境下，并发是指一段时间内宏观上有多个程序在同时运行，在微观上这些程序是分时交替的执行，而并行则是指同一时刻有两个或多个程序在执行。

并行需要硬件的支持，如多处理器。



#### 2.共享

共享是指操作系统中的资源可以提供给内存中多个并发的执行进程共同使用。

两种共享的方式：

- 互斥共享
- 同时访问

互斥共享的资源被称为临界资源，比如打印机，在同一段时间内只允许一个进程访问的资源，称为临界资源。

#### 3.虚拟化

虚拟就是把一个物理实体变成若干逻辑上的对应物。

比如将内存虚拟化为地址空间，将磁盘虚拟化为文件，将CPU虚拟化为进程

前者是实际存在的，而后者是虚的，只是用户感觉上存在而已。

主要的两种虚拟技术: 时分复用和空分复用技术。

时分复用：是指在利用某设备为一用户服务的空闲时间内，又转去为其他用户服务，使设备得到充分的利用。

空分复用：是指利用存储器的空闲分区域存放和运行其它的多道程序，来提高内存的利用率。  



#### 4.异步

异步是指进程不是一次执行完毕，而是走走停停，以不可知的速度向前推进。

### 进程管理

#### 1.进程

进程是指系统中能独立运行并作为资源分配的基本单位。

进程控制块（Process Control Block,PCB）描述进程的基本信息和运行状态，所谓创建进程和撤销进程都是对PCB进行操作。

#### 2.线程

线程是独立调度的基本单位。

一个进程中可以有多个线程，他们共享进程的资源。

### 3.进程和线程的区别

1.拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属于进程的资源。

2.调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程会引起进程的切换。

3.系统开销

由于创建和撤销进程，系统都要为之分配和回收资源，如内存空间，I/O设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存以及新调度进程CPU环境的设置。而进程切换时只需要保存和设置少量寄存器的内容，开销很小。

4.通信

线程间可以通过直接读写同一进程的数据进通信，但是进程的通信需要借助IPC

### 协程

更加轻量，在用户态进行调度，比线程上下文切换代价更加小

#### 进程的特征

- 动态性
- 并发性
- 独立性
- 异步性

### 进程状态的切换

- 就绪状态 ：等待被调度
- 运行状态
- 阻塞状态 ： 等待资源

注意一下内容：

- 只有就绪状态和运行状态可以相互切换，其它都是单向的转换，就绪状态的进程通过调度算法从而获得CPU时间，转为运行状态；而运行状态的进程，在分配给它的CPU时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU时间，缺少CPU时间会从运行状态转为就绪状态。

### 线程切换步骤：

进行中。。。

### 进程的调度算法

不同环境的调度算法目标不同，因此需要针对不同的环境来讨论调度算法。

### 1.批处理系统

批处理系统没有天多的用户操作，在该系统中，调度算法目标是保证系统的吞吐量和周转时间（从提交到终止的时间）。

##### 先来先服务

按照请求的顺序进行调度。

有利于长作业，但是不利于短作业，因为短作业必须一直等待前面长作业执行完毕之后才能执行，而长作业又需要执行很长的时间，造成了短作业等待时间过长。

##### 短作业优先

##### 最短剩余时间优先

##### 时间片轮转

##### 优先级调度

##### 多级反馈队列

### 程序并发执行的特征

- 间断性 
- 失去封闭性
- 不可再现性



## 大内核与微内核

### 1.大内核

大内核是将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。



#### 2.微内核

随着操作系统的不断复杂，因此将一部分操作系统的功能移除内核，从而降低内核的复杂性。移出的部分根据分成的原则划分成若干服务。相互独立。

在微内核结构下，操作系统划分成小的，定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户太。

因为需要频繁的在用户态和核心态之间进行切换，所以有一定的性能上的损失。



## 进程同步

### 临界区

### 同步和互斥

- 同步：多个进程按照一定的顺序执行
- 互斥：多个进程在同一时刻只有一个进程能进入临界区

### 信号量

信号量是一个整型变量，可以对其执行down和up操作，也就是常见的P和V操作。

- down：如果信号量大于0，执行-1操作；如果信号量等于0,进程睡眠，等待信号量大于0.
- up:对信号量执行+1操作，唤醒睡眠的进程让其完成down操作。

down和up操作需要被设计成原语，不可分割



### 中断分类

#### 1.外中断

由CPU执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

#### 2.异常

由CPU执行指令内部事件引起，如非法操作码，地址越界，算术溢出等。

#### 3.陷入

在用户程序中使用系统调用。



# 启动

DISK 存放OS

BIOS 基本IO处理系统

![1561808932054](E:\Git\TTMS\MX-Notes\image\1561808932054.png)

`BIOS` 负责将 `Bootloader` 从磁盘的引导扇区加载内存，`Bootloader` 将操作系统的代码和数据从硬盘加载到内存中。

## 系统调用

应用程序主动向操作系统发出服务请求，就是应用程序向操作系统发出的一条特殊的指令，异步和同步都有

## 异常

非法指令或者其它坏的处理状态，比如内存出错，同步的

步骤：异常编号

​	保存现场

​	异常处理：杀死产生了异常的程序或者重新执行异常的指令

​	恢复现场

## 中断

来自不同硬件设备的计时器和网络的中断，外设产生中断，中断是异步的

硬件设置中断标记，将内部、外部事件设置中断标记,产生中断事件ID将 ID号发送给OS

OS 保存当前的处理状态，根据中断ID中断服务程序处理，处理完之后清除中断标记，恢复之前保存的处理状态。

，为什么要使用操作系统？

在计算及运行中，内核是被信任的第三方，只有内核可以执行特殊的指令，为了方便应用程序





## 内存

操作系统控制了逻辑内存到物理内存之间的映射，并且负责内存检查。

抽象：逻辑地址空间

保护：独立地址空间

共享：访问相同内存

虚拟化：更多的地址空间

## 地址空间

物理地址空间：硬件支持的地址空间

逻辑地址空间：一个运行的程序所拥有的内存范围



## 连续内存的分配策略

### 首次适配

为了分配 n 字节，使用第一个可用空闲块的尺寸比 n 大。

简单实现：按地址排序的空闲块列表，分配需要寻找一个合适的分区，重分配需要检查，看是否自由分区能合并于相邻的口昂县分区。

优点是：简单，易于产生更大的空闲块，想着地址空间的结尾

缺点是：容易产生外部碎片，不确定性高

### 最佳分配

找到一个最合适的空间分配。

为了避免分割大的空闲块

为了最小化外部碎片产生的尺寸

优势：当大部分分配的是小尺寸时非常有效，比较简单

缺点：外部碎片，容易产生还能多没有用的微小碎片

## 最差适配

找到一个跟分配 n 个字节差距最大的空间进行分配。

优势：对分配是中等尺寸效果最好

缺点：重分配慢，外部碎片，易于破碎大的空闲块以至大的内存快无法分配。 



### 碎片整理：压缩式碎片整理和交换式碎片整理



## 非连续的内存分配管理

建立虚拟地址和物理地址之间的映射

### 分段: 更好的分离和共享

![1561824337170](E:\Git\TTMS\MX-Notes\image\1561824337170.png)





![1561824411962](E:\Git\TTMS\MX-Notes\image\1561824411962.png)

## 分页

划分物理内存至固定大小的帧

划分路基地址空间至相同大小的页

页的大小和叶帧的大小是相同的，页内便宜的大小等于帧内偏移的大小

![1561825641106](E:\Git\TTMS\MX-Notes\image\1561825641106.png)

多级页表，解决页表内容过大的问题



交换：操作系统将进程在内存与外存之间的交换，因而获得更多的空闲内存空间。

覆盖：不是将程序所有内容都放入内存中。



### 虚拟技术 - 局部性

时间局部性

空间局部性

## 虚拟技术-虚拟页式内存管理

当一个用户程序要调入内存运行时，不是将该程序的所有页面都装入内存，而只装入部分的页面，就可以启动程序运行。

在运行的过程中，如果发现运行的程序或要访问数据不在内存中，则向系如同发出却也中断请求，系统在处理这个中断的时候，将外存中相应的页面调入内存，使得该程序能够继续运行。

![1561897566769](E:\Git\TTMS\MX-Notes\image\1561897566769.png)

## 页面置换算法

功能：当缺页中断发生的时候，需要导入新的页面而内存已经满了，选择内存当中哪个物理页面被置换。

目标：尽可能地减少页面换进换出次数，具体来说把外来不再使用的或短期内使用较少的页面换出，通常只能在局部性原理指导下依据过去的统计数据来进行预测。

页面锁定：有些页面必须常驻内存的操作系统关键部分或时间关键的引用程序，我们可以在页表中添加锁定标志位。

- 最优置换算法

- 先进先出置换算法 实现方式系统维护一个链表，链表中记录了所有位于内存中的逻辑页面，从链表的排列顺序来看，链表首页的驻留时间最长，链表尾部页面的驻留时间最短，当发生一个缺页中断时候，把链表首页淘汰出局，并把新的页面添加到链表的末尾。

  性能较差，调出的页面有可能是经常要访问的页面。并且有 Belady 现象。FIFO 算法很少单独使用。

- 最近最久未使用算法LRU，当一个缺页中断发生的时候，选择最久未使用的那个页面，并淘汰。 根据局部性原理。

- LRU 算法需要记录各个页面使用时间的先后顺序。实现方式，系统维护一个页面链表，最近刚刚使用过的页面作为首节点，最久未使用的页面作为尾节点，每一次访问内存时候，找到相应的页面，把它从链表中摘下来，再移动到链表之首。每次缺页中断发生时，淘汰链表末尾的页面。

- 设置一个活动页面栈，当访问某页时，将此页号压入栈顶，然后靠找栈内是否有与此页面相同的页号，若有则抽出。当需要淘汰一个页面时候，总是选择栈底的页面，他就是最久未使用的。

- Clock 页面置换算法，LRU 的近似，对 FIFO 的一种改进；

  基本思路：需要用到页表项当中的访问问，当一个页面被装入内存时，把该位初始化为0。然后如果这个页面被访问，则把该位置为1；

  把各个页面组织程环形链表，把指针指向最老的页面

  当发生那个一个却也中断时，考察指针所指向的最老页面，若它的访问位为0，立即淘汰；若为1，则把该位置为0，然后指针往下移动一格。如此下去，知道找到淘汰的页面，然后把指针移动到它的下一格。

- 修改的Clock 算法，使它允许脏页中总是在一次始终扫描中保留下来。

  

| used | dirty | used    | dirty |
| ---- | ----- | ------- | ----- |
| 0    | 0     | replace | page  |
| 0    | 1     | 0       | 0     |
| 1    | 0     | 0       | 0     |
| 1    | 1     | 0       | 1     |



- 最不常用算法LRU

  当一个缺页中断发生的时候，选择访问系数最少的那个页面，并淘汰。

  对页面设置一个访问计数器，每当一个页面访问时候，该页面的访问计数器加一，当发生缺页中断的时候，淘汰最少。

LRU考察的是最久未访问，时间越短越好，而LRU考察的访问的次数或频度，访问次数越多越好。



## 进程

### 定义

一个具有一定功能的程序在一个数据集合上一次动态的执行过程。



### 进程的组成

![1561906331570](E:\Git\TTMS\MX-Notes\image\1561906331570.png)

### 进程和程序的联系

![1561906354233](E:\Git\TTMS\MX-Notes\image\1561906354233.png)

### 进程和程序的区别

![1561906641832](E:\Git\TTMS\MX-Notes\image\1561906641832.png)

### 进程的特点

![1561907005325](E:\Git\TTMS\MX-Notes\image\1561907005325.png)

### 进程控制块

![1561907210317](E:\Git\TTMS\MX-Notes\image\1561907210317.png)